.program:
ji   i4
noop
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
lw   $ds $is 1
add  $$ds $$ds $is
lw   $r1 $fp i73              ; load input function selector
lw   $r0 data_6               ; load fn selector for comparison
eq   $r0 $r1 $r0              ; function selector comparison
jnei $zero $r0 i11            ; jump to selected function
rvrt $zero                    ; revert if no selectors matched
lw   $r1 $fp i74              ; loading argument into abi function
lw   $r0 $r1 i0               ; Loading copy type: u64
addi $r1 $r1 i8               ; Construct pointer for struct field
lw   $r0 data_0               ; literal instantiation
lw   $r3 $r0 i0
lw   $r1 data_1               ; literal instantiation
lw   $r0 data_1               ; literal instantiation
lw   $r0 data_2               ; literal instantiation
move $r4 $r1
move $r0 $r3
lt   $r0 $r4 $r0
jnei $r0 $one i46
xos $r5 $r1
lw   $r0 $r5 i0
lw   $r4 data_3               ; literal instantiation
eq   $r0 $r0 $r4
jnei $r0 $one i41
addi $r0 $r5 i40
lw   $r2 $r0 i0
lw   $r4 data_1               ; literal instantiation
move $r0 $r2
eq   $r0 $r0 $r4
jnei $r0 $one i38
move $r0 $r1                  ; variable output_index reassignment
lw   $r0 data_4               ; literal instantiation
move $r1 $r3                  ; variable index reassignment
ji   i40                      ; end of then branch
lw   $r0 data_5               ; literal instantiation
add  $r1 $r0 $r1
ji   i43                      ; end of then branch
lw   $r0 data_5               ; literal instantiation
add  $r1 $r0 $r1
lw   $r0 data_5               ; literal instantiation
add  $r1 $r0 $r1
ji   i19
ret  $r2                      ; withdraw fn return value
.data:
data_0 .u64 0x2840
data_1 .u64 0x00
data_2 .bool 0x00
data_3 .u64 0x04
data_4 .bool 0x01
data_5 .u64 0x01
data_6 .u32 0x74d3818e

  Bytecode size is 244 bytes.
